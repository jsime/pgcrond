#!/usr/bin/env perl

use 5.010;

PGcrond->new->run;

exit;

package PGcrond;

use strict;
use warnings;

our $VERSION = '0.900001';
$VERSION = eval $VERSION;

sub new {
    my ($class) = @_;

    my $self = bless {}, $class;

    return $self;
}

sub run {
    my ($self) = @_;
}


package PGcrond::Crontab;

use strict;
use warnings;

sub new {
    my ($class) = @_;

    my $self = bless {}, $class;

    $self->reload;

    return $self;
}

sub reload {
    my ($self) = @_;

    # Locate all pgcrontabs (main and pgcrontab.d/* files)

    # Re-read/parse any that are either new or have an mtime greater than last reload() (or maybe a filehash?)
}


package PGcrond::Handler;

use strict;
use warnings;

sub run {
    my ($class, %opts) = @_;

    # fork and run command

    # deliver report (root@localhost if no MAILTO provided)
}

sub perl {
}

sub psql {
}

sub shell {
}

sub sql {
}


1;
__DATA__
use DateTime::Cron::Simple;
use DBIx::DataStore;
use File::HomeDir;
use POSIX qw( setsid );
use Proc::ProcessTable;

use constant PIDFILE => '/var/run/pgcrond.pid';
use constant PSTITLE => 'pgcrond';
use constant DEF_SCRIPTHOME => '/etc/pgcrond/scripts';
use constant PSQL_BINARY => '/usr/bin/psql';

sub new {
    my ($class) = @_;

    my $self = bless {}, $class;
    return $self;
}

sub run {
    my ($self) = @_;

    exit $self->usage if scalar(@ARGV) != 1 || $ARGV[0] =~ /^-{0,2}help$/oi;

    my $command = lc($ARGV[0]);
    $command =~ s/^\-+//og;

    exit daemon_print_status() if $command eq 'status';
    exit print "pgcrond $VERSION\n" if $command eq 'version';

    if ($command eq 'stop' || $command eq 'restart') {
        my $r = daemon_stop();
        exit $r if $command eq 'stop';
        exit $r if $command eq 'restart' && $r != 0;
    }

    exit daemon_start() if $command eq 'start' || $command eq 'restart';
}

sub usage {
    my ($self) = @_;

    print <<EOU;
pgcrond v$VERSION
  Copyright 2013, Jon Sime.
  This program is free software; you may redistribute it and/or modify
  it under the same terms as Perl itself.

For full documentation on this program and its related files, refer
to the man page.

Invocation: pgcrond <command>

Commands:

    start      Starts the pgcrond daemon if it is not currently
               running.

    stop       Stops the currently running pgcrond daemon.

    restart    Performs a full restart of the currently running
               pgcrond daemon (same as running "pgcrond stop"
               followed by "pgcrond start").

    status     Checks for an already-running pgcrond daemon and
               reports its state and PID if found.

    help       Displays this message and exits.

    version    Displays the pgcrond version number and exits.

EOU

    return 0;
}

sub check_pgcrontab {
	my %vars = ();
	my @entries = ();

	open(FH, '/etc/pgcrontab') or return 1;

	my $line_num = 0;

	PGCRONTAB_LINE:
	while (my $line = <FH>) {
		# TODO: 2.0 feature?
		# add some coolness to allow the config to override previously defined
		# variables in a location-aware way. IOW, VARX is defined at the top and
		# applies to all jobs below it, until VARX is redefined to something else
		# at which the new value applies to jobs defined after the new version.

		chomp($line);
		$line_num++;
		# skip comment-only and blank lines
		next PGCRONTAB_LINE if $line =~ /^\s*(#.*)?$/o;

		# strip any in-line comment
		$line =~ s/#.*$//o;

		# see if the line is a variable assignment, and if so, store it
		if ($line =~ /^(\w+)\s*=(.*)$/o) {
			my ($name, $val) = ($1, $2);
			$val =~ s/(^\s+|\s+$)//ogs; # remove trailing/leading whitespace
			$val =~ s/(^"|"$)//ogs; # remove double-quoting if present
			$vars{$name} = $val;
			next PGCRONTAB_LINE;
		}

		# theoretically, if we hit this point, it should be a runspec line
		my @runspec = split(/\s+/, $line);

		# skip any runspec line without enough columns (at some point this can
		# be changed to log out a warning with the line number)
		next PGCRONTAB_LINE unless scalar(@runspec) >= 12;

		my $timespec = join(' ', @runspec[0..4]);
		my $cmdspec = join(' ', @runspec[11..$#runspec]);

		next unless DateTime::Cron::Simple->new($timespec)->validate_time;

		# set aside the data for any action that should be kicked off in this run
		push(@entries, {
			timespec	=> $timespec,
			server		=> $runspec[5],
			port		=> $runspec[6],
			database	=> $runspec[7],
			user		=> $runspec[8],
			schema		=> $runspec[9],
			type		=> $runspec[10],
			command		=> $cmdspec,
		});
	}

	close(FH);

	# must get passwords from .pgpass files, not through environment
	delete $vars{'PGPASSWORD'} if exists $vars{'PGPASSWORD'};

	# make sure the script home is set properly
	if (defined $vars{'SCRIPTHOME'}) {
		$vars{'SCRIPTHOME'} .= '/' unless substr($vars{'SCRIPTHOME'}, -1, 1) eq '/';
	} else {
		$vars{'SCRIPTHOME'} = substr(DEF_SCRIPTHOME, -1, 1) eq '/'
			? DEF_SCRIPTHOME : DEF_SCRIPTHOME . '/';
	}

	$vars{'MAILTO'} = 'root' unless defined $vars{'MAILTO'} && length($vars{'MAILTO'}) > 0;

	$vars{'PSQL'} = PSQL_BINARY unless defined $vars{'PSQL'} && length($vars{'PSQL'}) > 0;

	foreach (@entries) {
		_handle_action(\%vars, $_);
	}

	return 0;
}

sub daemon_print_status {
	my ($pid);

	if ($pid = _get_daemon_pid()) {
		print STDERR "Started: $pid\n";
	} else {
		print STDERR "Stopped\n";
	}

	return 0;
}

sub daemon_start {
	my ($pid);

	if ($pid = _get_daemon_pid()) {
		print STDERR "pgcrond already running ($pid)!\n";
		return 1;
	}

	chdir('/') or die "Couldn't chdir to /: $!";
	open(STDIN, '/dev/null') or die "Couldn't redirect stdin from /dev/null: $!";
	open(STDOUT, '>/dev/null') or die "Couldn't redirect stdout to /dev/null: $!";
	defined ($pid = fork) or die "Couldn't fork: $!";
	exit if $pid;
	setsid or die "Couldn't start a new session: $!";
	open(STDERR, '>&STDOUT') or die "Couldn't redirect stderr to stdout: $!";

	$SIG{CHLD} = 'IGNORE'; # someone call social services!

	$pid = $$;

	$0 = PSTITLE;

	open(FH, '>' . PIDFILE) or die "Couldn't open PID file: $!";
	print FH $pid;
	close(FH);

	my $last = '0' x 12;

	while (1) {
		my $now = sprintf('%4d%02d%02d%02d%02d',
			(localtime)[5] + 1900, (localtime)[4] + 1, (localtime)[3,2,1]);

		if ($now gt $last) {
			$last = $now;
			check_pgcrontab();
		}

		sleep(1);
	}

	return 0;
}

sub daemon_stop {
	my ($pid);

	if ($pid = _get_daemon_pid()) {
		my $check_count = 0;

		print STDERR "Stopping pgcrond ($pid)..";

		while (_get_daemon_pid()) {
			if ($check_count > 25) {
				die "pgcrond stop failed (timeout)!\n";
			}

			kill 2, $pid;

			$check_count++;
			print STDERR ".";
			sleep(1);
		}
		print STDERR "stopped\n";
		return 0;
	} else {
		print STDERR "pgcrond not started\n";
		return 1;
	}

	return 0;
}

sub _get_daemon_pid {
	if (-e PIDFILE && open(FH, PIDFILE)) {
		my $pid = <FH>;
		close(FH);
		chomp($pid);

		if (grep { $_->pid eq $pid } @{ Proc::ProcessTable->new()->table }) {
			return $pid;
		}

		unlink(PIDFILE);
	}

	return;
}

sub _get_dsn {
	my ($vars, $action) = @_;

	# carry over any PG* vars set in crontab for job-specific fields set to "-"
	$action->{'server'} = $vars->{'PGHOST'} if defined $vars->{'PGHOST'} && length($vars->{'PGHOST'}) > 0
		&& $action->{'server'} eq '-';
	$action->{'port'} = $vars->{'PGPORT'} if defined $vars->{'PGPORT'} && length($vars->{'PGPORT'}) > 0
		&& $action->{'port'} eq '-';
	$action->{'database'} = $vars->{'PGDATABASE'} if defined $vars->{'PGDATABASE'} && length($vars->{'PGDATABASE'}) > 0
		&& $action->{'database'} eq '-';
	$action->{'user'} = $vars->{'PGUSER'} if defined $vars->{'PGUSER'} && length($vars->{'PGUSER'}) > 0
		&& $action->{'user'} eq '-';

	return if $action->{'database'} eq '-' || $action->{'user'} eq '-';

	my %dsn = (
		database	=> $action->{'database'},
		username	=> $action->{'user'}
	);

	if ($action->{'schema'} ne '-') {
		my @schemas = grep { $_ =~ /\w+/ } split(',', $action->{'schema'});
		if (substr($action->{'schema'}, -1, 1) eq ',' && scalar(grep { $_ =~ /^public$/oi } @schemas) < 1) {
			push(@schemas, 'public');
		}

		$dsn{'schemas'} = \@schemas if scalar(@schemas) > 0;
	}

	$dsn{'server'} = $action->{'server'} eq '-' ? 'localhost' : $action->{'server'};
	$dsn{'port'} = $action->{'port'} unless $action->{'port'} eq '-';

	my $homedir = File::HomeDir->my_home() || _report($vars, \%dsn, $action, "Error locating pgcrond's home directory");

	my $pgpass = $homedir . '/.pgpass';

	open(FH, $pgpass) || _report($vars, \%dsn, $action, "Error opening PostgreSQL password file: $!");

	PGPASS_LINE:
	while (<FH>) {
		chomp;
		my @t = split(':', $_);

		if (	($t[0] eq '*' || $t[0] eq $action->{'server'})
			&&	($t[1] eq '*' || $t[1] eq $action->{'port'})
			&&	($t[2] eq '*' || $t[2] eq $action->{'database'})
			&&	($t[3] eq '*' || $t[3] eq $action->{'user'})) {
			$dsn{'password'} = $t[4];
			last PGPASS_LINE;
		}
	}

	close(FH) || _report($vars, \%dsn, $action, "Error closing PostgreSQL password file: $!");

	# update $vars hashref with DSN data (since shell jobs may depend on those being set properly)
	if (defined $dsn{'server'}) {
		$vars->{'PGHOST'} = $dsn{'server'};
	} else {
		delete $vars->{'PGHOST'} if defined $vars->{'PGHOST'};
	}

	if (defined $dsn{'port'}) {
		$vars->{'PGPORT'} = $dsn{'port'};
	} else {
		delete $vars->{'PGPORT'} if defined $vars->{'PGPORT'};
	}

	if (defined $dsn{'database'}) {
		$vars->{'PGDATABASE'} = $dsn{'database'};
	} else {
		delete $vars->{'PGDATABASE'} if defined $vars->{'PGDATABASE'};
	}

	if (defined $dsn{'username'}) {
		$vars->{'PGUSER'} = $dsn{'username'};
	} else {
		delete $vars->{'PGUSER'} if defined $vars->{'PGUSER'};
	}

	return \%dsn;
}

sub _handle_action {
	my ($vars, $action) = @_;

	my ($pid);

	chdir('/') or die "Couldn't chdir to /: $!";
	open(STDIN, '/dev/null') or die "Couldn't redirect stdin from /dev/null: $!";
	open(STDOUT, '>/dev/null') or die "Couldn't redirect stdout to /dev/null: $!";
	defined ($pid = fork) or die "Couldn't fork: $!";
	return if $pid; # parent process entering child-only codespace, so return
	setsid or die "Couldn't start a new session: $!";
	open(STDERR, '>&STDOUT') or die "Couldn't redirect stderr to stdout: $!";

	$pid = $$;

	$0 = PSTITLE . ': ' . $action->{'command'};

	my $dsn = _get_dsn($vars, $action);

	my ($output);

	$output = _handle_direct($vars, $dsn, $action) if lc($action->{'type'}) eq 'direct';
	$output = _handle_psql($vars, $dsn, $action) if lc($action->{'type'}) eq 'psql';
	$output = _handle_perl($vars, $dsn, $action) if lc($action->{'type'}) eq 'perl';
	$output = _handle_sh($vars, $dsn, $action) if lc($action->{'type'}) eq 'sh';

	if (defined $output && length($output) > 0 && $output != 1) {
		_report($vars, $dsn, $action, $output);
	}

	exit 0;
}

sub _handle_direct {
	my ($vars, $dsn, $action) = @_;

	my $config = {
		default_reader => 'none',
		primary => {
			driver	=> 'Pg',
			db		=> $dsn->{'database'},
			user	=> $dsn->{'username'},
			pass	=> $dsn->{'password'},
		}
	};
	$config->{'primary'}->{'host'} = $dsn->{'server'} if defined $dsn->{'server'};
	$config->{'primary'}->{'port'} = $dsn->{'port'} if defined $dsn->{'port'};
	$config->{'primary'}->{'schemas'} = $dsn->{'schemas'} if defined $dsn->{'schemas'};

	my $db = DBIx::DataStore->new({ config => $config }) || _report($vars, $dsn, $action, "Error connecting to database");

	$db->begin;

	my $res = $db->do($action->{'command'});

	my ($output);

	if ($res) {
		$db->commit;
		# this will be beefed up to actually take results of SELECT operations,
		# prettify them and mail back to the MAILTO
	} else {
		$db->rollback;
		_report($vars, $dsn, $action, "Error performing SQL operation: " . $res->error);
	}

	return $output;
}

sub _handle_perl {
	my ($vars, $dsn, $action) = @_;

	my $filename = substr($action->{'command'}, 0, 1) eq '/'
		? $action->{'command'}
		: $vars->{'SCRIPTHOME'} . $action->{'command'};
	
	unless (-r $filename) {
		_report($vars, $dsn, $action, "Invalid Perl script file provided");
	}

	my $config = {
		default_reader => 'none',
		primary => {
			driver	=> 'Pg',
			db		=> $dsn->{'database'},
			user	=> $dsn->{'username'},
			pass	=> $dsn->{'password'},
		}
	};
	$config->{'primary'}->{'host'} = $dsn->{'server'} if defined $dsn->{'server'};
	$config->{'primary'}->{'port'} = $dsn->{'port'} if defined $dsn->{'port'};
	$config->{'primary'}->{'schemas'} = $dsn->{'schemas'} if defined $dsn->{'schemas'};

	my $db = DBIx::DataStore->new({ config => $config }) || _report($vars, $dsn, $action, "Error connecting to database");

	my ($output);

	eval {
		require $filename;
		$output = run($vars, $dsn, $action, $db);
	};
	
	_report($vars, $dsn, $action, "Error executing Perl script: $@") if $@;

	return $output;
}

sub _handle_psql {
	my ($vars, $dsn, $action) = @_;

	# possibly beef this up to use a temp copy of the psql session script to
	# pass through schemas (as of right now, pgcrontab settings for schemas
	# on psql jobs are effectively ignored -- not ideal)

	my $filename = substr($action->{'command'}, 0, 1) eq '/'
		? $action->{'command'}
		: $vars->{'SCRIPTHOME'} . $action->{'command'};
	
	unless (-r $filename) {
		_report($vars, $dsn, $action, "Invalid PostgreSQL session file provided");
	}

	my $dsn_args = "-U $dsn->{'username'} -d $dsn->{'database'}";
	$dsn_args .= " -h $dsn->{'server'}" if defined $dsn->{'server'};
	$dsn_args .= " -p $dsn->{'port'}" if defined $dsn->{'port'};

	my ($output);

	open(PSQL, "$vars->{'PSQL'} $dsn_args < $filename 2>&1|")
		|| _report($vars, $dsn, $action, "Error opening pipe to psql program: $!");

	while (<PSQL>) {
		$output .= $_;
	}

	close(PSQL);

	# this is ugly and non-configurable, but i hate all the cron emails we currently get because
	# of various materialized view jobs that run every couple minutes
	return $output if $output =~ /(WARNING|ERROR)/os; # send output back if there were warnings or errors
	return $output if $output =~ /Time:\s+\d{5,}\.\d+\s+ms/os; # \timing was on and any single query ran 10+ seconds
	return; # otherwise don't send output back, thus triggering no emails
}

sub _handle_sh {
	my ($vars, $dsn, $action) = @_;

	my $env = join(' ', map { qq|$_="$vars->{$_}"| if exists $vars->{$_} } qw( PGHOST PGPORT PGDATABASE PGUSER ));

	my ($output);

	local $SIG{PIPE} = 'IGNORE';

	open(SHELL, "$env $action->{'command'} 2>&1 |")
		|| _report($vars, $dsn, $action, "Error opening shell pipe: $!");

	while (<SHELL>) {
		$output .= $_;
	}

	close(SHELL);

	return $output;
}

sub _report {
	my ($vars, $dsn, $action, $msg) = @_;

	my $pid = $$;
	my $now = localtime;

	# by default add a section at the top of the notifications summarizing the DSN info
	unless (defined $vars->{'DSN_IN_MAIL'}
		&& ($vars->{'DSN_IN_MAIL'} == 0 || $vars->{'DSN_IN_MAIL'} =~ /^(off|no)$/io)) {
		my $dsn_info = '-' x 11 . '[Database]' . '-' x 11 . "\n";

		$dsn_info .= "    Server: $dsn->{'server'}\n" if defined $dsn->{'server'};
		$dsn_info .= "      Port: $dsn->{'port'}\n" if defined $dsn->{'port'};
		$dsn_info .= "  Database: $dsn->{'database'}\n";
		$dsn_info .= "      User: $dsn->{'username'}\n";
		$dsn_info .= "   Schemas: " . join(', ', @{$dsn->{'schemas'}}) . "\n" if defined $dsn->{'schemas'};

		$dsn_info .= '-' x 32 . "\n\n";

		$msg = $dsn_info . $msg;
	}

	my $mail = MIME::Lite->new(
		From	=> 'pgcrond daemon <root@localhost>',
		To		=> $vars->{'MAILTO'},
		Subject	=> "[pgcrond] $action->{'command'}",
		Data	=> $msg,
	);

	$mail->send;

	exit;
}
